/*861. 翻转矩阵后的得分
有一个二维矩阵 A 其中每个元素的值为 0 或 1 。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

返回尽可能高的分数。

 

示例：

输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
 

提示：

1 <= A.length <= 20
1 <= A[0].length <= 20
A[i][j] 是 0 或 1
通过次数4,890 提交次数6,596 */

/**
 * 个人的思路：
 * 
 * 翻转某一列的行为: 变大还是变小，取决于0 -> 1, 和1 -> 0那种情况更多
 * 也就是翻转的列的0, 1哪个数目更多
 * 0更多，变大；1更多，变小
 * 
 * 翻转某一行的行为: 二进制中, 最高位 > 最大的其余位之和
 * 变大还是变小，取决于最高位是0, 还是1。前者变大，后者变小。
 * 
 * 多阶段最优决策问题
 * 满足无后效性但却不满足最优子结构
 * 最优解未必是从上一个最优解转移过来的
 * 
 * 所以动态规划在这里行不通了...
 * 
 * 思路断了，先考虑一般解法
 * 
 * 列出该矩阵的所有可能的状态, 再比较大小
 * 
 * 如何列出呢？
 * 
 * 单看某一位，状态既可以是0，也可以是1
 * 
 * 单看某一行，状态既可以是当前状态取反，也可以是在这基础上对列翻转，进而实现单个位状态的改变
 * 
 * 单看某一列，跟行可能的状态相同
 * 
 * 是否真的可以取到所有的2^(n^2)个状态?
 * 
 * 如果可以还求个锤子，全部取1就行了...
 * 
 * 哪些状态可以取到？ 
 * 
 * 在同一个位置所在的行和列同时翻转，对该位等于没有影响
 * 
 * 求和可以看做，每一个位的值单独相加
 * 
 * 想不下去了，换个思路
 * 
 * 什么情况是最大的？不再需要继续翻转
 * 
 * 最高位的1尽可能多
 * 
 * 满足上一个条件的时候，次高位的1尽可能多
 * 
 * 以此类推
 * 
 * 结合之前的分析, 为了满足第一点
 * 
 * 必然同为0的行，或同为1的行(后翻转列)，需要翻转一次
 * 
 * 后面为了满足第二位1尽可能多
 * 
 * 已经不能进行行的翻转了，影响了第一位得不偿失
 * 
 * 之后就只用考虑列的翻转，而这是不会影响后面的列的
 * 
 * 当前列1更多，那么就不翻转
 * 
 * 当前列0更多，那么就翻转1次
 * 
 * 唯一存在抉择的就是第一次，翻转0的行还是1的行
 * 
 * 取决于，除去第一列，后面只做列变化的矩阵大小
 * 
 * 好麻烦，都算一下不就好了...
 * 
 * 后面发现，其实两个是同质的
 * 
 * 翻转所有0的行，等于翻转余下所有1的行 + 翻转余下列（翻转两次 和 不翻转 是同质的，那么被翻转的其实就只有0的行）
 * 
 * (这其实也说明行翻转是不会影响列翻转的)
 * 
 * 两个下标x, y
 * 
 * x控制列的遍历，y控制行的遍历
 * 
 * 复杂度为x*y, 也就是平方的复杂度
 * 
 * 基本操作是翻转，行，列
 * 
 * 位运算作为操作单元也不会很慢
 * 
 * */

#include<vector>
#include<cmath>
#include<iostream>
using namespace std;
using std::size_t;


int matrixScore(vector<vector<int>>& A) {
    /**
     * 一个误区是必须转换成二进制的形式
     * 但这道题只要求求值
     * 所以没必要改变这个数组
     **/
    int max_score = 0;


    //仅有的一次的行操作
    for (auto& row : A)
        if (row[0] == 1)
            for (auto& x : row)
                x = 1 - x;

    int row_length = A.size();
    int column_length = A[0].size();

    // 列操作
    for(size_t x = 0; x < column_length; ++x)
    {
        size_t zero_num = 0;
        size_t one_num = 0;
        for (size_t y = 0; y < row_length; ++y)
            A[y][x] == 0 ? ++zero_num : ++one_num;
        max_score += pow(2, column_length - x - 1) * max(zero_num, one_num);
        // printf("max_score: %d\n", max_score);
    }

    return max_score;

}

int main() {

    vector<vector<int>> A {};
    A.push_back(vector<int> {0,0,1,1});
    A.push_back(vector<int> {1,0,1,0});
    A.push_back(vector<int> {1,1,0,0});

    printf("max_score: %d\n", matrixScore(A));

    return 0;
}
